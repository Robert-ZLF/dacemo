<!DOCTYPE HTML>
<html lang="en">
<head>
	<title>DaCeMo Visualisation</title>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
</head>
<body class="homepage">


<a href="/DaCeMo_war_exploded/getGraph">Get graphInfo</a>
<!-- Header https://templated.co/linear-->
<div id="header">
	<div id="nav-wrapper">
		<!-- Nav -->
		<nav id="nav">
			<ul>
				<li class="active"><a href="index.html">Homepage</a></li>
			</ul>
		</nav>
	</div>
	<div class="container">
		<!-- Logo -->
		<div id="logo">
			<h1><a href="#">DaCeMo Visualisation</a></h1>
		</div>
	</div>
</div>

<!-- Featured -->
<div id="featured">
	<div class="container">
		<header>
			<h2>Welcome to DaCeMo Visualisation</h2>
		</header>
		<p>
			<img src="images/header.jpg" width="100" height="100" alt="Image of a graph."/>
		</p>

		<p>This is <strong>DaCeMo Visualisation</strong>,  A website that displays a navigable, query-able, and understandable graph representation of a Data-Centric Model (DaCeMo) of an Enterprise.
			A complex domain made understandable to enterprise users from middle management, to IT, to CEOs, through varying layers of data abstraction.
			DaCeMo is an approach to modelling Enterprise as a set of OWL (Web Ontology Language) Ontologies.</p>
		<hr />
	</div>
</div>

<div id="comment"></div>
<button onclick="callServer('POST')">UpdateGraph</button>

<div id="myDiv"><h2>Let AJAX change this text</h2></div>

<div id ="d3 graph">
	<svg width="1080" height="400"></svg>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script>

		var getString;
		var nodeArray;
		var baseNodes;
		var baseLinks;
		var nodes;
		var links;


		function updateNode() {
			console.log(getString);
			nodeArray = getString.split(',');

			console.log(nodeArray);
			baseNodes = new Array(parseInt(nodeArray.length/4));

			for(i =0;i<parseInt(nodeArray.length/4);i++){
				console.log(nodeArray[0]);
				baseNodes[i] = new Object();
				baseNodes[i].id = nodeArray[4 *i];
				baseNodes[i].group = parseInt(nodeArray[4 *i +1]);
				baseNodes[i].label = nodeArray[4 *i +2];
				baseNodes[i].level = parseInt(nodeArray[4 *i +3]);

			}



			baseLinks = new Array(parseInt(baseNodes.length/2));

			for(i =0;i<baseLinks.length;i++){
				var link = new Object();
				link.target = baseNodes[i].id;
				link.source = baseNodes[i+1].id;
				link.strength = 0.1;
				baseLinks[i] = link;
			}



			nodes = [...baseNodes]
			links = [...baseLinks]
		}


		function callServer(methodType) {
			var xmlResruest;

			if(window.XMLHttpRequest){
				xmlResruest = new XMLHttpRequest();
			}else if(window.ActiveXObject){
				xmlResruest = new ActiveXObject("MICROSOFT.XMLHTTP");
			}

			xmlResruest.onreadystatechange = function(){
				if(xmlResruest.readyState ==4 && xmlResruest.status ==200){
					document.getElementById("myDiv").innerHTML = "button down";
					getString = xmlResruest.responseText;
					document.getElementById("myDiv").innerHTML = getString;
					updateNode();
					updateSimulation();
				}

			}

			params = "comment=" + document.getElementById("comment").value;
			if(methodType =="GET"){
				xmlResruest.open("GET","/DaCeMo_war_exploded/getGraph?"+params,true);
				xmlResruest.send();

			}else if(methodType =="POST"){
				xmlResruest.open("POST","/DaCeMo_war_exploded/getGraph",true);
				xmlResruest.setRequestHeader("req","req");
				xmlResruest.send(params);

			}

		}


		function getNeighbors(node) {
			return baseLinks.reduce(function (neighbors, link) {
						if (link.target.id === node.id) {
							neighbors.push(link.source.id)
						} else if (link.source.id === node.id) {
							neighbors.push(link.target.id)
						}
						return neighbors
					},
					[node.id]
			)
		}

		function isNeighborLink(node, link) {
			return link.target.id === node.id || link.source.id === node.id
		}


		function getNodeColor(node, neighbors) {
			if (Array.isArray(neighbors) && neighbors.indexOf(node.id) > -1) {
				return node.level === 1 ? 'blue' : 'green'
			}

			return node.level === 1 ? 'red' : 'gray'
		}


		function getLinkColor(node, link) {
			return isNeighborLink(node, link) ? 'green' : '#E5E5E5'
		}

		function getTextColor(node, neighbors) {
			return Array.isArray(neighbors) && neighbors.indexOf(node.id) > -1 ? 'green' : 'black'
		}

		var width = window.innerWidth
		var height = window.innerHeight

		var svg = d3.select('svg')
		svg.attr('width', width).attr('height', height)

		var linkElements,
				nodeElements,
				textElements

		// we use svg groups to logically group the elements together
		var linkGroup = svg.append('g').attr('class', 'links')
		var nodeGroup = svg.append('g').attr('class', 'nodes')
		var textGroup = svg.append('g').attr('class', 'texts')

		// we use this reference to select/deselect
		// after clicking the same element twice
		var selectedId

		// simulation setup with all forces
		var linkForce = d3
				.forceLink()
				.id(function (link) { return link.id })
				.strength(function (link) { return link.strength })

		var simulation = d3
				.forceSimulation()
				.force('link', linkForce)
				.force('charge', d3.forceManyBody().strength(-120))
				.force('center', d3.forceCenter(width / 2, height / 2))

		var dragDrop = d3.drag().on('start', function (node) {
			node.fx = node.x
			node.fy = node.y
		}).on('drag', function (node) {
			simulation.alphaTarget(0.7).restart()
			node.fx = d3.event.x
			node.fy = d3.event.y
		}).on('end', function (node) {
			if (!d3.event.active) {
				simulation.alphaTarget(0)
			}
			node.fx = null
			node.fy = null
		})

		// select node is called on every click
		// we either update the data according to the selection
		// or reset the data if the same node is clicked twice
		function selectNode(selectedNode) {
			if (selectedId === selectedNode.id) {
				selectedId = undefined
				resetData()
				updateSimulation()
			} else {
				selectedId = selectedNode.id
				updateData(selectedNode)
				updateSimulation()
			}

			var neighbors = getNeighbors(selectedNode)

			// we modify the styles to highlight selected nodes
			nodeElements.attr('fill', function (node) { return getNodeColor(node, neighbors) })
			textElements.attr('fill', function (node) { return getTextColor(node, neighbors) })
			linkElements.attr('stroke', function (link) { return getLinkColor(selectedNode, link) })
		}

		// this helper simple adds all nodes and links
		// that are missing, to recreate the initial state
		function resetData() {
			var nodeIds = nodes.map(function (node) { return node.id })

			baseNodes.forEach(function (node) {
				if (nodeIds.indexOf(node.id) === -1) {
					nodes.push(node)
				}
			})

			links = baseLinks
		}

		// diffing and mutating the data
		function updateData(selectedNode) {
			var neighbors = getNeighbors(selectedNode)
			var newNodes = baseNodes.filter(function (node) {
				return neighbors.indexOf(node.id) > -1 || node.level === 1
			})

			var diff = {
				removed: nodes.filter(function (node) { return newNodes.indexOf(node) === -1 }),
				added: newNodes.filter(function (node) { return nodes.indexOf(node) === -1 })
			}

			diff.removed.forEach(function (node) { nodes.splice(nodes.indexOf(node), 1) })
			diff.added.forEach(function (node) { nodes.push(node) })

			links = baseLinks.filter(function (link) {
				return link.target.id === selectedNode.id || link.source.id === selectedNode.id
			})
		}

		function updateGraph() {
			// links
			linkElements = linkGroup.selectAll('line')
					.data(links, function (link) {
						return link.target.id + link.source.id
					})

			linkElements.exit().remove()

			var linkEnter = linkElements
					.enter().append('line')
					.attr('stroke-width', 1)
					.attr('stroke', 'rgba(50, 50, 50, 0.2)')

			linkElements = linkEnter.merge(linkElements)

			// nodes
			nodeElements = nodeGroup.selectAll('circle')
					.data(nodes, function (node) { return node.id })

			nodeElements.exit().remove()

			var nodeEnter = nodeElements
					.enter()
					.append('circle')
					.attr('r', 10)
					.attr('fill', function (node) { return node.level === 1 ? 'red' : 'gray' })
					.call(dragDrop)
					// we link the selectNode method here
					// to update the graph on every click
					.on('click', selectNode)

			nodeElements = nodeEnter.merge(nodeElements)

			// texts
			textElements = textGroup.selectAll('text')
					.data(nodes, function (node) { return node.id })

			textElements.exit().remove()

			var textEnter = textElements
					.enter()
					.append('text')
					.text(function (node) { return node.label })
					.attr('font-size', 15)
					.attr('dx', 15)
					.attr('dy', 4)

			textElements = textEnter.merge(textElements)
		}

		function updateSimulation() {
			updateGraph()

			simulation.nodes(nodes).on('tick', () => {
				nodeElements
				.attr('cx', function (node) { return node.x })
						.attr('cy', function (node) { return node.y })
				textElements
				.attr('x', function (node) { return node.x })
						.attr('y', function (node) { return node.y })
				linkElements
				.attr('x1', function (link) { return link.source.x })
						.attr('y1', function (link) { return link.source.y })
						.attr('x2', function (link) { return link.target.x })
						.attr('y2', function (link) { return link.target.y })
			})

			simulation.force('link').links(links)
			simulation.alphaTarget(0.7).restart()
		}

		// last but not least, we call updateSimulation
		// to trigger the initial render


	</script>
</div>


<!-- Footer -->
<div id="footer">
	<div class="container">
		<section>
			<header>
				<h2>Contacts</h2>
				<span class="byline">61XXXXXXXX</span>
			</header>
		</section>
	</div>
</div>



</body>
</html>